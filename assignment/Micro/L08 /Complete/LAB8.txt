
LAB08
จากโค้ดโปรแกรม EX01:

1. **โค้ดบรรทัดที่ 5 (`Serial.begin(9600);`) ทำหน้าที่อะไร:**
   ทำหน้าที่เริ่มต้นการสื่อสารผ่านพอร์ตอนุกรม (Serial Communication) ด้วยอัตราการส่งข้อมูลที่ 9600 บิตต่อวินาที (baud rate)

2. **โค้ดบรรทัดที่ 10 (`if(Serial.available())`) ทำหน้าที่อะไร:**
   ตรวจสอบว่ามีข้อมูลที่พร้อมจะถูกอ่านจากพอร์ตอนุกรมหรือไม่

3. **โค้ดบรรทัดที่ 12 (`key = Serial.read();`) ทำหน้าที่อะไร:**
   อ่านข้อมูลที่ได้รับจากพอร์ตอนุกรมและเก็บไว้ในตัวแปร `key`

4. **ถ้ารับตัวอักษร “a” เข้ามา หลอด LED จะ ติด หรือ ดับ:**
   *ติด*

5. **ถ้ารับตัวอักษร “b” เข้ามา หลอด LED จะ ติด หรือ ดับ:**
   *ดับ* 

จากโค้ดโปรแกรม EX01PY:

1. **โค้ดบรรทัดที่ 4 (`ser = serial.Serial('COM2',9600)`) ทำหน้าที่อะไร:**
   สร้างการเชื่อมต่อพอร์ตอนุกรมกับอุปกรณ์ที่เชื่อมต่ออยู่ที่พอร์ต COM2 โดยใช้บอดเรต (baud rate) ที่ 9600

2. **โค้ดบรรทัดที่ 6 (`ser.open()`) ทำหน้าที่อะไร:**
   เปิดการเชื่อมต่อพอร์ตอนุกรมหากยังไม่ได้เปิดอยู่

3. **โค้ดบรรทัดที่ 10 (`delay = 1`) ทำหน้าที่อะไร:**
   กำหนดค่าตัวแปร `delay` ให้เท่ากับ 1 วินาที ซึ่งใช้เป็นระยะเวลาหน่วงก่อนที่จะส่งข้อมูลครั้งต่อไป

4. **โค้ดบรรทัดที่ 12 (`while (True):`) ทำหน้าที่อะไร:**
   เริ่มต้นลูปที่ทำงานอย่างต่อเนื่อง (ลูปไม่สิ้นสุด) เพื่อส่งข้อมูลไปยัง Arduino ตลอดเวลา

5. **โค้ดบรรทัดที่ 13 (`ser.write(str.encode('a'))`) ทำหน้าที่อะไร:**
   ส่งข้อมูลตัวอักษร 'a' ไปยัง Arduino ผ่านพอร์ตอนุกรม

6. **โค้ดบรรทัดที่ 17 (`ser.write(str.encode('b'))`) ทำหน้าที่อะไร:**
   ส่งข้อมูลตัวอักษร 'b' ไปยัง Arduino ผ่านพอร์ตอนุกรม

จากโค้ดโปรแกรม EX02:

1. **โค้ดบรรทัดที่ 20 และ 21 (`if (Serial.available()) textin = Serial.readStringUntil('\n');`) ทำหน้าที่อะไร:**
   ตรวจสอบว่ามีข้อมูลที่พร้อมจะถูกอ่านจากพอร์ตอนุกรมหรือไม่ หากมี จะอ่านข้อมูลที่รับเข้ามาจนถึงตัวอักษร newline ('\n') และเก็บในตัวแปร `textin`

2. **โค้ดบรรทัดที่ 23 และ 24 (`if (textin == "a0") digitalWrite(led_a,LOW);`) ทำหน้าที่อะไร:**
   ตรวจสอบว่าข้อความที่ได้รับเป็น "a0" หรือไม่ หากใช่ จะสั่งให้ปิด (ดับ) LED ที่เชื่อมต่อกับพิน `led_a`

3. **โค้ดบรรทัดที่ 25 และ 26 (`if (textin == "a1") digitalWrite(led_a,HIGH);`) ทำหน้าที่อะไร:**
   ตรวจสอบว่าข้อความที่ได้รับเป็น "a1" หรือไม่ หากใช่ จะสั่งให้เปิด (ติด) LED ที่เชื่อมต่อกับพิน `led_a`

4. **โค้ดบรรทัดที่ 43 ถึง 49 ทำหน้าที่อะไร:**
   ตรวจสอบว่าข้อความที่ได้รับเป็น "onall" หรือไม่ หากใช่ จะสั่งให้เปิด (ติด) LED ทั้งหมดที่เชื่อมต่อกับพิน `led_a`, `led_b`, `led_c`, และ `led_d`

5. **โค้ดบรรทัดที่ 50 ถึง 56 ทำหน้าที่อะไร:**
   ตรวจสอบว่าข้อความที่ได้รับเป็น "offall" หรือไม่ หากใช่ จะสั่งให้ปิด (ดับ) LED ทั้งหมดที่เชื่อมต่อกับพิน `led_a`, `led_b`, `led_c`, และ `led_d`


จากโค้ดโปรแกรม EX02:

1. **โค้ดบรรทัดที่ 20 และ 21 (`if (Serial.available()) textin = Serial.readStringUntil('\n');`) ทำหน้าที่อะไร:**
   ตรวจสอบว่ามีข้อมูลที่พร้อมจะถูกอ่านจากพอร์ตอนุกรมหรือไม่ หากมี จะอ่านข้อมูลที่รับเข้ามาจนถึงตัวอักษร newline ('\n') และเก็บในตัวแปร `textin`

2. **โค้ดบรรทัดที่ 23 และ 24 (`if (textin == "a0") digitalWrite(led_a,LOW);`) ทำหน้าที่อะไร:**
   ตรวจสอบว่าข้อความที่ได้รับเป็น "a0" หรือไม่ หากใช่ จะสั่งให้ปิด (ดับ) LED ที่เชื่อมต่อกับพิน `led_a`

3. **โค้ดบรรทัดที่ 25 และ 26 (`if (textin == "a1") digitalWrite(led_a,HIGH);`) ทำหน้าที่อะไร:**
   ตรวจสอบว่าข้อความที่ได้รับเป็น "a1" หรือไม่ หากใช่ จะสั่งให้เปิด (ติด) LED ที่เชื่อมต่อกับพิน `led_a`

4. **โค้ดบรรทัดที่ 43 ถึง 49 ทำหน้าที่อะไร:**
   ตรวจสอบว่าข้อความที่ได้รับเป็น "onall" หรือไม่ หากใช่ จะสั่งให้เปิด (ติด) LED ทั้งหมดที่เชื่อมต่อกับพิน `led_a`, `led_b`, `led_c`, และ `led_d`

5. **โค้ดบรรทัดที่ 50 ถึง 56 ทำหน้าที่อะไร:**
   ตรวจสอบว่าข้อความที่ได้รับเป็น "offall" หรือไม่ หากใช่ จะสั่งให้ปิด (ดับ) LED ทั้งหมดที่เชื่อมต่อกับพิน `led_a`, `led_b`, `led_c`, และ `led_d`



จากโค้ดโปรแกรม EX02PY:

1. **โค้ดบรรทัดที่ 11 (`text_com = input("Enter command : ")`) ทำหน้าที่อะไร:**
   รอรับคำสั่งจากผู้ใช้ผ่านทางคีย์บอร์ด โดยเก็บข้อความที่ผู้ใช้ป้อนเข้ามาในตัวแปร `text_com`

2. **โค้ดบรรทัดที่ 12 (`ser.write(str.encode(text_com))`) ทำหน้าที่อะไร:**
   ส่งข้อมูลที่ผู้ใช้ป้อนเข้ามา (ซึ่งเก็บอยู่ในตัวแปร `text_com`) ไปยัง Arduino ผ่านการเชื่อมต่อพอร์ตอนุกรม



จากโค้ดโปรแกรม EX03:

1. **โค้ดบรรทัดที่ 13 (`TextIn = Serial.readStringUntil('\n');`) ทำหน้าที่อะไร:**
   อ่านข้อมูลจากพอร์ตอนุกรมที่เข้ามาจนถึงตัวอักษร newline ('\n') แล้วเก็บข้อมูลที่อ่านได้ในตัวแปร `TextIn`

2. **โค้ดบรรทัดที่ 17 ถึง 24 ทำหน้าที่อะไร:**
   ตรวจสอบว่าข้อความที่ได้รับ (`TextIn`) เริ่มต้นด้วย "L1:" หรือไม่ ถ้าใช่ จะตัดส่วนของข้อความหลัง "L1:" มาแสดงบนบรรทัดที่ 1 ของหน้าจอ LCD โดยเคลียร์บรรทัดก่อนแล้วพิมพ์ข้อความใหม่

3. **โค้ดบรรทัดที่ 26 ถึง 33 ทำหน้าที่อะไร:**
   ตรวจสอบว่าข้อความที่ได้รับ (`TextIn`) เริ่มต้นด้วย "L2:" หรือไม่ ถ้าใช่ จะตัดส่วนของข้อความหลัง "L2:" มาแสดงบนบรรทัดที่ 2 ของหน้าจอ LCD โดยเคลียร์บรรทัดก่อนแล้วพิมพ์ข้อความใหม่

4. **โค้ดบรรทัดที่ 35 และ 36 ทำหน้าที่อะไร:**
   ตรวจสอบว่าข้อความที่ได้รับ (`TextIn`) เท่ากับ "clearall" หรือไม่ ถ้าใช่ จะล้าง (เคลียร์) ข้อความทั้งหมดที่แสดงอยู่บนหน้าจอ LCD




จากโค้ดโปรแกรม EX03PY:

1. **โค้ดบรรทัดที่ 10 (`ser.write(str.encode("L1:Hello Python\n"))`) ทำหน้าที่อะไร:**
   ส่งข้อความ "L1:Hello Python" ไปยัง Arduino ผ่านพอร์ตอนุกรม โดยข้อความนี้จะถูกใช้ในการแสดงผลที่บรรทัดที่ 1 ของหน้าจอ LCD

2. **โค้ดบรรทัดที่ 13 (`text = input("Enter Text : ")`) ทำหน้าที่อะไร:**
   รอรับข้อความจากผู้ใช้ผ่านทางคีย์บอร์ดและเก็บข้อความนั้นไว้ในตัวแปร `text`

3. **โค้ดบรรทัดที่ 14 (`ser.write(str.encode(text))`) ทำหน้าที่อะไร:**
   ส่งข้อความที่ผู้ใช้ป้อนเข้ามา (ซึ่งเก็บอยู่ในตัวแปร `text`) ไปยัง Arduino ผ่านการเชื่อมต่อพอร์ตอนุกรม



จากโค้ดโปรแกรม EX04:

1. **โค้ดบรรทัดที่ 13 และ 14 (`if (digitalRead(sw1) == LOW) Serial.println("sw1");`) ทำหน้าที่อะไร:**
   ตรวจสอบสถานะของสวิตช์ `sw1` ว่าถูกกดหรือไม่ (ค่าต่ำหรือ `LOW`) ถ้าถูกกด จะส่งข้อความ "sw1" ไปยังพอร์ตอนุกรมเพื่อแสดงผลที่ Python

2. **โค้ดบรรทัดที่ 16 และ 17 (`if (digitalRead(sw2) == LOW) Serial.println("sw2");`) ทำหน้าที่อะไร:**
   ตรวจสอบสถานะของสวิตช์ `sw2` ว่าถูกกดหรือไม่ (ค่าต่ำหรือ `LOW`) ถ้าถูกกด จะส่งข้อความ "sw2" ไปยังพอร์ตอนุกรมเพื่อแสดงผลที่ Python

3. **โค้ดบรรทัดที่ 19 ถึง 20 (`if (digitalRead(sw3) == LOW) Serial.println("sw3");`) ทำหน้าที่อะไร:**
   ตรวจสอบสถานะของสวิตช์ `sw3` ว่าถูกกดหรือไม่ (ค่าต่ำหรือ `LOW`) ถ้าถูกกด จะส่งข้อความ "sw3" ไปยังพอร์ตอนุกรมเพื่อแสดงผลที่ Python



จากโค้ดโปรแกรม EX04PY:

1. **โค้ดบรรทัดที่ 11 (`if ser.inWaiting():`) ทำหน้าที่อะไร:**
   ตรวจสอบว่ามีข้อมูลรออยู่ในบัฟเฟอร์พอร์ตอนุกรมหรือไม่ หากมีข้อมูลจะส่งผลเป็น `True`

2. **โค้ดบรรทัดที่ 12 (`text = ser.readline().decode()[:-2]`) ทำหน้าที่อะไร:**
   อ่านข้อมูลหนึ่งบรรทัดจากพอร์ตอนุกรมและแปลงข้อมูลนั้นจากรูปแบบไบต์ (byte) เป็นสตริง (string) โดยตัดอักขระท้ายสองตัวออก (เช่น newline หรือ carriage return)

3. **โค้ดบรรทัดที่ 13 (`print(text)`) ทำหน้าที่อะไร:**
   แสดงข้อความที่อ่านจากพอร์ตอนุกรมออกทางหน้าจอ Python Shell



จากโค้ดโปรแกรม EX05:

1. **โค้ดบรรทัดที่ 8 (`aval = analogRead(A0);`) ทำหน้าที่อะไร:**
   อ่านค่าจากขาอนาล็อก A0 ของ Arduino แล้วเก็บค่าไว้ในตัวแปร `aval`

2. **โค้ดบรรทัดที่ 9 (`x = map(aval,0,1023,0,100);`) ทำหน้าที่อะไร:**
   แปลงค่าที่อ่านได้จาก `aval` ซึ่งอยู่ในช่วง 0 ถึง 1023 ไปเป็นค่าที่อยู่ในช่วง 0 ถึง 100 แล้วเก็บผลลัพธ์ไว้ในตัวแปร `x`

3. **โค้ดบรรทัดที่ 10 (`Serial.println(x);`) ทำหน้าที่อะไร:**
   ส่งค่าของตัวแปร `x` ไปยังพอร์ตอนุกรมเพื่อแสดงผลที่ Python


จากโค้ดโปรแกรม EX05PY:

1. **โค้ดบรรทัดที่ 13 (`num = int(text)`) ทำหน้าที่อะไร:**
   แปลงข้อมูลที่ได้รับจากพอร์ตอนุกรม (ซึ่งเก็บอยู่ในตัวแปร `text`) จากสตริง (string) ให้เป็นจำนวนเต็ม (integer) และเก็บผลลัพธ์ไว้ในตัวแปร `num`



จากโค้ดโปรแกรม EX06:

1. **โค้ดบรรทัดที่ 12 ถึง 16:**
   ```cpp
   digitalWrite(triggerPin, LOW);
   delayMicroseconds(2);
   digitalWrite(triggerPin, HIGH);
   delayMicroseconds(10);
   digitalWrite(triggerPin, LOW);
   ```
   ทำหน้าที่กระตุ้นสัญญาณให้กับ Ultrasonic Sensor โดยส่งสัญญาณพัลส์ (pulse) ไปที่ขา `triggerPin`:
   - ตั้งค่าขา `triggerPin` เป็น `LOW` เพื่อเริ่มต้น
   - รอเวลา 2 ไมโครวินาที
   - ตั้งค่าขา `triggerPin` เป็น `HIGH` เพื่อส่งสัญญาณทริกเกอร์ (trigger pulse) เป็นเวลา 10 ไมโครวินาที
   - ตั้งค่าขา `triggerPin` กลับเป็น `LOW` เพื่อสิ้นสุดสัญญาณทริกเกอร์

2. **โค้ดบรรทัดที่ 19 (`Serial.println(distCM);`) ทำหน้าที่อะไร:**
   ส่งค่าระยะทางที่คำนวณได้ (`distCM`) จาก Ultrasonic Sensor ไปยังพอร์ตอนุกรมเพื่อแสดงผลที่ Python



จากโค้ดโปรแกรม EX06PY:

1. **โค้ดบรรทัดที่ 13 (`print("ระยะทาง = " + text + " cm")`) ทำหน้าที่อะไร:**
   แสดงข้อความระยะทางที่วัดได้จาก Ultrasonic Sensor บนหน้าจอ Python Shell โดยข้อความที่แสดงจะประกอบด้วยคำว่า "ระยะทาง = " ตามด้วยค่าระยะทางที่ได้รับจากพอร์ตอนุกรม (ตัวแปร `text`) และหน่วยเป็น "cm"



จากโค้ดโปรแกรม EX07:

1. **โค้ดบรรทัดที่ 9 (`bool gas_val = digitalRead(gaspin);`) ทำหน้าที่อะไร:**
   อ่านค่าสัญญาณดิจิทัลจากขา `gaspin` (ขาที่เชื่อมต่อกับ Gas/Smoke Sensor) และเก็บค่าที่อ่านได้ (ค่าต่ำ `LOW` หรือค่าสูง `HIGH`) ไว้ในตัวแปร `gas_val` ซึ่งเป็นชนิดข้อมูลแบบบูลีน (boolean)

2. **โค้ดบรรทัดที่ 10 ถึง 14:**
   ```cpp
   if (gas_val == HIGH)
   {
       Serial.println("Found SMOKE");
       delay(2000);
   }
   ```
   ทำหน้าที่ตรวจสอบค่าของตัวแปร `gas_val`:
   - ถ้าค่าเป็น `HIGH` แสดงว่ามีการตรวจพบควัน (SMOKE) จะส่งข้อความ "Found SMOKE" ไปยังพอร์ตอนุกรมเพื่อแจ้งเตือน และหยุดรอเป็นเวลา 2000 มิลลิวินาที (2 วินาที) ก่อนทำงานต่อไป



จากโค้ดโปรแกรม EX08:

1. **โค้ดบรรทัดที่ 15 และ 16 (`if (digitalRead(sw1) == LOW) Serial.println("sw1");`) ทำหน้าที่อะไร:**
   ตรวจสอบสถานะของสวิตช์ `sw1` ว่าถูกกดหรือไม่ (มีค่าเป็น `LOW`) ถ้าถูกกด จะส่งข้อความ "sw1" ไปยังพอร์ตอนุกรมเพื่อแจ้งให้ Python ทราบ

2. **โค้ดบรรทัดที่ 18 และ 19 (`if (digitalRead(sw2) == LOW) Serial.println("sw2");`) ทำหน้าที่อะไร:**
   ตรวจสอบสถานะของสวิตช์ `sw2` ว่าถูกกดหรือไม่ (มีค่าเป็น `LOW`) ถ้าถูกกด จะส่งข้อความ "sw2" ไปยังพอร์ตอนุกรมเพื่อแจ้งให้ Python ทราบ

3. **โค้ดบรรทัดที่ 21 และ 22 (`if (digitalRead(sw3) == LOW) Serial.println("sw3");`) ทำหน้าที่อะไร:**
   ตรวจสอบสถานะของสวิตช์ `sw3` ว่าถูกกดหรือไม่ (มีค่าเป็น `LOW`) ถ้าถูกกด จะส่งข้อความ "sw3" ไปยังพอร์ตอนุกรมเพื่อแจ้งให้ Python ทราบ

4. **โค้ดบรรทัดที่ 24 และ 25 (`if (digitalRead(sw4) == LOW) Serial.println("sw4");`) ทำหน้าที่อะไร:**
   ตรวจสอบสถานะของสวิตช์ `sw4` ว่าถูกกดหรือไม่ (มีค่าเป็น `LOW`) ถ้าถูกกด จะส่งข้อความ "sw4" ไปยังพอร์ตอนุกรมเพื่อแจ้งให้ Python ทราบ



จากโค้ดโปรแกรม EX08PY:

1. **โค้ดบรรทัดที่ 5 (`img1 = cv2.imread("dog.jpg")`) ทำหน้าที่อะไร:**
   โหลดไฟล์ภาพชื่อ "dog.jpg" เข้าสู่ตัวแปร `img1` โดยใช้ฟังก์ชัน `imread` ของ OpenCV เพื่อเตรียมภาพสำหรับการแสดงผล

2. **โค้ดบรรทัดที่ 8 (`cv2.imshow("Image",img1)`) ทำหน้าที่อะไร:**
   แสดงภาพที่เก็บอยู่ในตัวแปร `img1` ในหน้าต่างชื่อ "Image" โดยใช้ฟังก์ชัน `imshow` ของ OpenCV

3. **โค้ดบรรทัดที่ 19 และ 20 (`if (text == "sw1"): cv2.imshow("Image",img1)`) ทำหน้าที่อะไร:**
   ตรวจสอบว่าข้อความที่ได้รับจากพอร์ตอนุกรมเป็น "sw1" หรือไม่ หากใช่ จะแสดงภาพที่เก็บอยู่ในตัวแปร `img1` (ภาพ "dog.jpg") ในหน้าต่างชื่อ "Image"

4. **โค้ดบรรทัดที่ 25 และ 26 (`elif (text == "sw4"): break`) ทำหน้าที่อะไร:**
   ตรวจสอบว่าข้อความที่ได้รับจากพอร์ตอนุกรมเป็น "sw4" หรือไม่ หากใช่ จะหยุดลูปการทำงานและออกจากโปรแกรม

5. **โค้ดบรรทัดที่ 30 (`cv2.destroyAllWindows()`) ทำหน้าที่อะไร:**
   ปิดหน้าต่างทั้งหมดที่เปิดโดย OpenCV เพื่อคืนค่าทรัพยากรที่ใช้แสดงภาพ



จากโค้ดโปรแกรม EX09:

1. **โค้ดบรรทัดที่ 8 (`x = analogRead(A0);`) ทำหน้าที่อะไร:**
   อ่านค่าจากขาอนาล็อก A0 ของ Arduino แล้วเก็บค่าไว้ในตัวแปร `x`

2. **โค้ดบรรทัดที่ 9 (`y = map(x,0,1023,30,200);`) ทำหน้าที่อะไร:**
   แปลงค่าที่อ่านได้จาก `x` ซึ่งอยู่ในช่วง 0 ถึง 1023 ให้เป็นช่วง 30 ถึง 200 แล้วเก็บผลลัพธ์ไว้ในตัวแปร `y`

3. **โค้ดบรรทัดที่ 10 (`Serial.println(y);`) ทำหน้าที่อะไร:**
   ส่งค่าของตัวแปร `y` ไปยังพอร์ตอนุกรมเพื่อแสดงผลที่ Python



จากโค้ดโปรแกรม EX09PY:

1. **โค้ดบรรทัดที่ 10 (`a = 1`) ทำหน้าที่อะไร:**
   กำหนดค่าตัวแปร `a` เริ่มต้นเป็น 1 เพื่อใช้ในการปรับขนาดของภาพที่ได้รับจากกล้องเว็บแคม

2. **โค้ดบรรทัดที่ 12 (`cap = cv2.VideoCapture(0)`) ทำหน้าที่อะไร:**
   เปิดการเชื่อมต่อกับกล้องเว็บแคม (อุปกรณ์หมายเลข 0) เพื่อเตรียมการรับภาพจากกล้องโดยใช้ OpenCV

3. **โค้ดบรรทัดที่ 14 (`while(cap.isOpened()):`) ทำหน้าที่อะไร:**
   เริ่มต้นลูปที่ทำงานต่อเนื่องตราบใดที่กล้องเว็บแคมยังคงเปิดใช้งานอยู่ (`cap.isOpened()` เป็น `True`)

4. **โค้ดบรรทัดที่ 15 (`ret, img = cap.read()`) ทำหน้าที่อะไร:**
   อ่านเฟรมภาพจากกล้องเว็บแคมแล้วเก็บไว้ในตัวแปร `img` และตัวแปร `ret` ซึ่งบ่งบอกถึงสถานะความสำเร็จในการอ่านภาพ

5. **โค้ดบรรทัดที่ 16 (`img = cv2.flip(img,1)`) ทำหน้าที่อะไร:**
   พลิกภาพ `img` ในแนวนอน (ภาพกลับด้านซ้าย-ขวา) โดยใช้ฟังก์ชัน `flip` ของ OpenCV

6. **โค้ดบรรทัดที่ 19 (`a = float(ser.readline().decode()[:-2])/100.0`) ทำหน้าที่อะไร:**
   อ่านค่าข้อมูลจากพอร์ตอนุกรม แปลงเป็นสตริง ตัดอักขระท้ายสองตัวออก จากนั้นแปลงเป็นจำนวนทศนิยม และหารด้วย 100 เพื่อใช้ในการปรับขนาดภาพ

7. **โค้ดบรรทัดที่ 22 (`img = cv2.resize(img,None,fx=a,fy=a)`) ทำหน้าที่อะไร:**
   ปรับขนาดภาพ `img` โดยใช้ค่าตัวคูณ `fx` และ `fy` ที่กำหนดด้วยตัวแปร `a` ซึ่งกำหนดอัตราส่วนในการขยายหรือย่อภาพ

8. **โค้ดบรรทัดที่ 25 และ 26 (`if cv2.waitKey(1) & 0xFF == ord('q'): break`) ทำหน้าที่อะไร:**
   ตรวจสอบว่ามีการกดปุ่ม 'q' บนแป้นพิมพ์หรือไม่ หากมีการกด จะออกจากลูปและปิดโปรแกรมแสดงผลภาพ




จากโค้ดโปรแกรม EX10:

1. **โค้ดบรรทัดที่ 14 และ 15:**
   ```cpp
   sensors.requestTemperatures();  
   Tint = sensors.getTempCByIndex(0);
   ```
   ทำหน้าที่ขอให้อุปกรณ์วัดอุณหภูมิ (DS18B20) ทำการวัดอุณหภูมิใหม่:
   - `sensors.requestTemperatures();` สั่งให้เซ็นเซอร์วัดอุณหภูมิใหม่
   - `Tint = sensors.getTempCByIndex(0);` อ่านค่าอุณหภูมิในรูปแบบองศาเซลเซียสจากเซ็นเซอร์ตัวแรก (index 0) และเก็บไว้ในตัวแปร `Tint`

2. **โค้ดบรรทัดที่ 18 (`Serial.println(Tint);`) ทำหน้าที่อะไร:**
   ส่งค่าของตัวแปร `Tint` (ซึ่งเป็นค่าอุณหภูมิที่ได้จากเซ็นเซอร์) ไปยังพอร์ตอนุกรมเพื่อแสดงผลที่ Python หรืออุปกรณ์ที่เชื่อมต่ออยู่



จากโค้ดโปรแกรม EX10PY:

1. **โค้ดบรรทัดที่ 19 (`dt = time.localtime()`) ทำหน้าที่อะไร:**
   ดึงข้อมูลเวลาปัจจุบันจากระบบและเก็บไว้ในตัวแปร `dt` ในรูปแบบโครงสร้างเวลาที่มีองค์ประกอบต่างๆ เช่น ปี, เดือน, วัน, ชั่วโมง, นาที และวินาที

2. **โค้ดบรรทัดที่ 21 และ 22:**
   ```python
   DD = "{:02d}/{:02d}/{:04d}".format(dt[2],dt[1],dt[0])
   TT = "{:02d}:{:02d}:{:02d}".format(dt[3],dt[4],dt[5])
   ```
   สร้างสตริง `DD` และ `TT` เพื่อแสดงวันที่ (`DD`) และเวลาปัจจุบัน (`TT`) ในรูปแบบที่อ่านได้ง่าย:
   - `DD` จัดรูปแบบเป็น "วัน/เดือน/ปี"
   - `TT` จัดรูปแบบเป็น "ชั่วโมง:นาที:วินาที"

3. **โค้ดบรรทัดที่ 24 และ 25:**
   ```python
   cv2.putText(img,DD,(100,100),font,1,(0,255,0),3)
   cv2.putText(img,TT,(350,100),font,1,(0,0,255),3)
   ```
   แสดงข้อความวันที่ (`DD`) และเวลา (`TT`) บนภาพ (`img`) โดย:
   - วางข้อความ `DD` ที่ตำแหน่งพิกัด (100,100) ด้วยสีเขียว `(0,255,0)`
   - วางข้อความ `TT` ที่ตำแหน่งพิกัด (350,100) ด้วยสีแดง `(0,0,255)`

4. **โค้ดบรรทัดที่ 28 (`a = ser.readline().decode()[:-2]`) ทำหน้าที่อะไร:**
   อ่านข้อมูลอุณหภูมิที่ได้รับจาก Arduino ผ่านพอร์ตอนุกรม แปลงข้อมูลจากไบต์เป็นสตริง และตัดอักขระสองตัวสุดท้าย (newline หรือ carriage return) ออก แล้วเก็บไว้ในตัวแปร `a`

5. **โค้ดบรรทัดที่ 30 (`cv2.putText(img,'T = '+a + ' C',(100,150),font,1,(255,255,0),3)`) ทำหน้าที่อะไร:**
   แสดงข้อความอุณหภูมิ (`a`) ที่ได้รับบนภาพ (`img`) ในตำแหน่ง (100,150) ด้วยสีเหลือง `(255,255,0)` โดยรูปแบบข้อความคือ "T = [ค่าอุณหภูมิ] C"

6. **โค้ดบรรทัดที่ 32 (`cv2.imshow("img",img)`) ทำหน้าที่อะไร:**
   แสดงภาพ (`img`) ที่มีการวางข้อความข้อมูลวันที่, เวลา, และอุณหภูมิบนหน้าต่างที่ชื่อว่า "img"



จากโค้ดโปรแกรม EX11:

1. **โค้ดบรรทัดที่ 29 และ 30:**
   ```cpp
   if (digitalRead(sw5) == LOW)
       Serial.println("sw5");    
   ```
   ทำหน้าที่ตรวจสอบสถานะของสวิตช์ `sw5` ว่าถูกกดหรือไม่ (มีค่าเป็น `LOW`) หากสวิตช์ `sw5` ถูกกด จะส่งข้อความ `"sw5"` ไปยังพอร์ตอนุกรมเพื่อแจ้งให้ Python ทราบ




จากโค้ดโปรแกรม EX11PY:

1. **โค้ดบรรทัดที่ 4 (`import line_api`) ทำหน้าที่อะไร:**
   นำเข้าโมดูล `line_api` ซึ่งเป็นไลบรารีที่ใช้ในการส่งข้อความแจ้งเตือนผ่าน LINE Notify

2. **โค้ดบรรทัดที่ 5 (`mytoken = '...'`) ทำหน้าที่อะไร:**
   กำหนดตัวแปร `mytoken` เพื่อเก็บค่าโทเค็นของ LINE Notify ซึ่งใช้ในการระบุตัวตนสำหรับการส่งข้อความแจ้งเตือนไปยังผู้ใช้หรือกลุ่ม

3. **โค้ดบรรทัดที่ 18 ถึง 21:**
   ```python
   if (text == "sw1"):
       text = "สวัสดีวันจันทร์"
       line_api.lineNotify(text,mytoken)
       print("ส่งข้อความ")
   ```
   ทำหน้าที่ตรวจสอบว่าข้อความที่ได้รับจากพอร์ตอนุกรมคือ `"sw1"` หรือไม่ หากใช่ จะสร้างข้อความ "สวัสดีวันจันทร์" และส่งข้อความนี้ผ่าน LINE Notify โดยใช้ฟังก์ชัน `lineNotify` และแสดงข้อความ "ส่งข้อความ" บนหน้าจอ

4. **โค้ดบรรทัดที่ 23 ถึง 27:**
   ```python
   elif (text == "sw2"):
       temp = 25.6
       text_temp = 'อุณหภูมิ = ' + str(temp) + ' องศาเซลเซียส'
       line_api.lineNotify(text_temp,mytoken)
       print("ส่งค่าในตัวแปร")
   ```
   ทำหน้าที่ตรวจสอบว่าข้อความที่ได้รับจากพอร์ตอนุกรมคือ `"sw2"` หรือไม่ หากใช่ จะสร้างข้อความแสดงอุณหภูมิและส่งข้อความนี้ผ่าน LINE Notify โดยใช้ฟังก์ชัน `lineNotify` และแสดงข้อความ "ส่งค่าในตัวแปร" บนหน้าจอ

5. **โค้ดบรรทัดที่ 29 ถึง 33:**
   ```python
   elif (text == "sw3"):
       line_api.notifySticker(3,1,mytoken)
       line_api.notifySticker(430,1,mytoken)
       line_api.notifySticker(149,2,mytoken)
       print("ส่งสติกเกอร์")
   ```
   ทำหน้าที่ตรวจสอบว่าข้อความที่ได้รับจากพอร์ตอนุกรมคือ `"sw3"` หรือไม่ หากใช่ จะส่งสติกเกอร์ 3 แบบผ่าน LINE Notify และแสดงข้อความ "ส่งสติกเกอร์" บนหน้าจอ

6. **โค้ดบรรทัดที่ 35 ถึง 38:**
   ```python
   elif (text == "sw4"):
       line_api.notifyFile('dog.jpg',mytoken)
       line_api.notifyFile('zebra.jpg',mytoken)
       print("ส่งรูปภาพ")
   ```
   ทำหน้าที่ตรวจสอบว่าข้อความที่ได้รับจากพอร์ตอนุกรมคือ `"sw4"` หรือไม่ หากใช่ จะส่งไฟล์ภาพ "dog.jpg" และ "zebra.jpg" ผ่าน LINE Notify และแสดงข้อความ "ส่งรูปภาพ" บนหน้าจอ

7. **โค้ดบรรทัดที่ 40 และ 41:**
   ```python
   elif (text == "sw5"):
       break
   ```
   ทำหน้าที่ตรวจสอบว่าข้อความที่ได้รับจากพอร์ตอนุกรมคือ `"sw5"` หรือไม่ หากใช่ จะออกจากลูปการทำงาน (หยุดการทำงานของโปรแกรม)




จากโค้ดโปรแกรม EX12:

1. **โค้ดบรรทัดที่ 16 และ 17:**
   ```cpp
   sensors.requestTemperatures();  
   Tint = sensors.getTempCByIndex(0);
   ```
   ทำหน้าที่ขอให้อุปกรณ์วัดอุณหภูมิ (DS18B20) ทำการวัดอุณหภูมิใหม่:
   - `sensors.requestTemperatures();` สั่งให้เซ็นเซอร์ DS18B20 วัดอุณหภูมิใหม่
   - `Tint = sensors.getTempCByIndex(0);` อ่านค่าอุณหภูมิในรูปแบบองศาเซลเซียสจากเซ็นเซอร์ตัวแรก (index 0) และเก็บไว้ในตัวแปร `Tint`

2. **โค้ดบรรทัดที่ 18 ถึง 25:**
   ```cpp
   if (digitalRead(sw1) == LOW)
   {
       if ((Tint > 0) && (Tint < 50))
       {
           Serial.println(Tint);
           delay(500);
       }
   }
   ```
   ทำหน้าที่ตรวจสอบสถานะของสวิตช์ `sw1` และเงื่อนไขของอุณหภูมิ:
   - ตรวจสอบว่าถ้าสวิตช์ `sw1` ถูกกด (มีค่าเป็น `LOW`)
   - ภายในเงื่อนไขนี้, ถ้าอุณหภูมิ `Tint` อยู่ในช่วงระหว่าง 0 ถึง 50 องศาเซลเซียส จะส่งค่าของ `Tint` ไปยังพอร์ตอนุกรมเพื่อแสดงผล และหยุดรอเป็นเวลา 500 มิลลิวินาที (0.5 วินาที) ก่อนดำเนินการตรวจสอบเงื่อนไขใหม่อีกครั้ง




จากโค้ดโปรแกรม EX12PY:

1. **โค้ดบรรทัดที่ 16 (`temp = ser.readline().decode()[:-2]`) ทำหน้าที่อะไร:**
   อ่านข้อมูลอุณหภูมิจากพอร์ตอนุกรมที่ได้รับจาก Arduino โดยแปลงข้อมูลจากรูปแบบไบต์ (byte) เป็นสตริง (string) แล้วตัดอักขระสองตัวท้ายออก (เช่น newline หรือ carriage return) และเก็บไว้ในตัวแปร `temp`

2. **โค้ดบรรทัดที่ 17 (`print("อุณหภูมิ = " + temp + " C")`) ทำหน้าที่อะไร:**
   แสดงข้อความ "อุณหภูมิ = [ค่าอุณหภูมิ] C" บนหน้าจอ Python Shell โดยจะแทนที่ `[ค่าอุณหภูมิ]` ด้วยค่าที่เก็บอยู่ในตัวแปร `temp` เพื่อแจ้งเตือนผู้ใช้เกี่ยวกับอุณหภูมิที่ได้รับจาก Arduino



จากโค้ดโปรแกรม EX13:

1. **โค้ดบรรทัดที่ 9 (`Wire.begin(4);`) ทำหน้าที่อะไร:**
   เริ่มต้นการสื่อสารแบบ I2C (Inter-Integrated Circuit) โดยกำหนดให้อุปกรณ์นี้ทำงานเป็น I2C slave (ผู้รับ) และตั้งค่า address ของอุปกรณ์ I2C นี้เป็นหมายเลข 4

2. **โค้ดบรรทัดที่ 11 (`Wire.onReceive(receiveEvent);`) ทำหน้าที่อะไร:**
   กำหนดฟังก์ชัน `receiveEvent` ให้ทำงานเมื่อมีการรับข้อมูลจาก master (ผู้ส่ง) ผ่าน I2C bus โดยฟังก์ชันนี้จะถูกเรียกใช้โดยอัตโนมัติเมื่อมีข้อมูลเข้ามาถึง slave ที่ address หมายเลข 4




จากโค้ดโปรแกรม EX13PY:

1. **โค้ดบรรทัดที่ 33 (`bus = smbus.SMBus(1)`) ทำหน้าที่อะไร:**
   สร้างอินสแตนซ์ของ SMBus (System Management Bus) เพื่อใช้สำหรับการสื่อสารผ่าน I2C bus โดยเลือกใช้อินเตอร์เฟซหมายเลข 1 (ซึ่งมักใช้ในระบบที่มี I2C bus หลายตัว)

2. **โค้ดบรรทัดที่ 35 (`address = 0x04`) ทำหน้าที่อะไร:**
   กำหนดตัวแปร `address` ให้มีค่าเป็น `0x04` ซึ่งเป็นที่อยู่ (address) ของอุปกรณ์ I2C slave ที่จะใช้ในการสื่อสาร

3. **โค้ดบรรทัดที่ 38 (`bus.write_byte(address, ord('H'))`) ทำหน้าที่อะไร:**
   ส่งข้อมูลหนึ่งไบต์ (byte) ไปยังอุปกรณ์ I2C slave ที่ที่อยู่ `0x04` โดยข้อมูลที่ส่งคืออักขระ `'H'` (ซึ่งถูกแปลงเป็นค่าตัวเลข ASCII ด้วยฟังก์ชัน `ord`) ผ่าน SMBus
